# This code has been automatically generated by:
# dev_scripts/test_codegen/generate_test_for_jsonization_of_concrete_classes.py
# Do NOT edit or append.


"""Test JSON de/serialization of concrete classes."""


# pylint: disable=missing-docstring


import json
import unittest
from typing import Optional

import aas_core3.jsonization as aas_jsonization
import aas_core3.verification as aas_verification

import tests.common
import tests.common_jsonization


class Test_Extension(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Extension`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Extension"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Extension/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Extension/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_AdministrativeInformation(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.AdministrativeInformation`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "AdministrativeInformation"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/AdministrativeInformation/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/AdministrativeInformation/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_Qualifier(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Qualifier`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Qualifier"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Qualifier/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Qualifier/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_AssetAdministrationShell(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.AssetAdministrationShell`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "AssetAdministrationShell"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/AssetAdministrationShell/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/AssetAdministrationShell/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_AssetInformation(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.AssetInformation`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "AssetInformation"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/AssetInformation/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/AssetInformation/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_Resource(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Resource`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Resource"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Resource/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Resource/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_SpecificAssetID(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.SpecificAssetID`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "SpecificAssetId"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/SpecificAssetId/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/SpecificAssetId/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_Submodel(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Submodel`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Submodel"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Submodel/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Submodel/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_RelationshipElement(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.RelationshipElement`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "RelationshipElement"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/RelationshipElement/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/RelationshipElement/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_SubmodelElementList(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.SubmodelElementList`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "SubmodelElementList"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/SubmodelElementList/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/SubmodelElementList/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_SubmodelElementCollection(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.SubmodelElementCollection`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "SubmodelElementCollection"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/SubmodelElementCollection/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/SubmodelElementCollection/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_Property(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Property`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Property"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Property/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Property/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_MultiLanguageProperty(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.MultiLanguageProperty`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "MultiLanguageProperty"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/MultiLanguageProperty/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/MultiLanguageProperty/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_Range(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Range`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Range"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Range/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Range/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_ReferenceElement(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.ReferenceElement`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "ReferenceElement"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/ReferenceElement/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/ReferenceElement/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_Blob(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Blob`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Blob"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Blob/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Blob/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_File(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.File`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "File"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/File/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/File/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_AnnotatedRelationshipElement(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.AnnotatedRelationshipElement`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "AnnotatedRelationshipElement"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/AnnotatedRelationshipElement/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/AnnotatedRelationshipElement/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_Entity(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Entity`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Entity"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Entity/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Entity/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_EventPayload(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.EventPayload`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "SelfContained"
                / "Expected"
                / "EventPayload"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            instance = aas_jsonization.event_payload_from_jsonable(jsonable)

            errors = list(aas_verification.verify(instance))

            self.assertListEqual([], errors, f"path is: {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(instance)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.event_payload_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "SelfContained"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/EventPayload/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.event_payload_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "SelfContained"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/EventPayload/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                instance = aas_jsonization.event_payload_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(instance))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_BasicEventElement(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.BasicEventElement`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "BasicEventElement"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/BasicEventElement/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/BasicEventElement/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_Operation(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Operation`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Operation"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Operation/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Operation/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_OperationVariable(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.OperationVariable`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "OperationVariable"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/OperationVariable/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/OperationVariable/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_Capability(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Capability`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Capability"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Capability/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Capability/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_ConceptDescription(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.ConceptDescription`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "ConceptDescription"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/ConceptDescription/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/ConceptDescription/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_Reference(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Reference`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Reference"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Reference/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Reference/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_Key(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Key`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Key"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Key/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Key/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_LangStringNameType(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.LangStringNameType`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "LangStringNameType"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/LangStringNameType/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/LangStringNameType/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_LangStringTextType(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.LangStringTextType`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "LangStringTextType"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/LangStringTextType/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/LangStringTextType/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_Environment(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Environment`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "SelfContained"
                / "Expected"
                / "Environment"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            instance = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(instance))

            self.assertListEqual([], errors, f"path is: {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(instance)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "SelfContained"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Environment/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "SelfContained"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/Environment/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                instance = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(instance))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_EmbeddedDataSpecification(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.EmbeddedDataSpecification`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "EmbeddedDataSpecification"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/EmbeddedDataSpecification/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/EmbeddedDataSpecification/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_LevelType(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.LevelType`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "LevelType"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/LevelType/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/LevelType/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_ValueReferencePair(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.ValueReferencePair`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "ValueReferencePair"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/ValueReferencePair/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/ValueReferencePair/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_ValueList(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.ValueList`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "ValueList"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/ValueList/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/ValueList/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_LangStringPreferredNameTypeIEC61360(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.LangStringPreferredNameTypeIEC61360`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "LangStringPreferredNameTypeIec61360"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/LangStringPreferredNameTypeIec61360/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/LangStringPreferredNameTypeIec61360/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_LangStringShortNameTypeIEC61360(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.LangStringShortNameTypeIEC61360`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "LangStringShortNameTypeIec61360"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/LangStringShortNameTypeIec61360/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/LangStringShortNameTypeIec61360/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_LangStringDefinitionTypeIEC61360(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.LangStringDefinitionTypeIEC61360`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "LangStringDefinitionTypeIec61360"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/LangStringDefinitionTypeIec61360/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/LangStringDefinitionTypeIec61360/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


class Test_DataSpecificationIEC61360(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.DataSpecificationIEC61360`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "DataSpecificationIec61360"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        unserializable_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Unserializable"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/DataSpecificationIec61360/**/*.json"

        paths = sorted(unserializable_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            observed_exception: Optional[
                aas_jsonization.DeserializationException
            ] = None

            try:
                _ = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                observed_exception = exception

            assert (
                observed_exception is not None
            ), f"Expected an exception, but got none for: {path}"

            tests.common.record_or_check(
                path=path.parent / (path.name + ".exception"),
                got=f"{observed_exception.path}: {observed_exception.cause}",
            )

    def test_verification_failures(self) -> None:
        invalid_dir = (
            tests.common.TEST_DATA_DIR
            / "Json"
            / "ContainedInEnvironment"
            / "Unexpected"
            / "Invalid"
        )

        # The first ``*`` corresponds to the cause.
        glob_pattern = "*/DataSpecificationIec61360/**/*.json"

        paths = sorted(invalid_dir.glob(glob_pattern))

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            try:
                container = aas_jsonization.environment_from_jsonable(jsonable)
            except aas_jsonization.DeserializationException as exception:
                raise AssertionError(
                    f"Expected no deserialization exception from {path}"
                ) from exception

            errors = list(aas_verification.verify(container))

            self.assertGreater(
                len(errors),
                0,
                f"Expected verification errors from {path}, but got none",
            )

            tests.common.record_or_check(
                path=path.parent / (path.name + ".errors"),
                got="\n".join(f"{error.path}: {error.cause}" for error in errors),
            )


if __name__ == "__main__":
    unittest.main()


# This code has been automatically generated by:
# dev_scripts/test_codegen/generate_test_for_jsonization_of_concrete_classes.py
# Do NOT edit or append.
