# This code has been automatically generated by:
# dev_scripts/test_codegen/generate_test_for_jsonization_of_concrete_classes.py
# Do NOT edit or append.


"""Test JSON de/serialization of concrete classes."""


# pylint: disable=missing-docstring


import json
import unittest
from typing import Optional

import aas_core3.jsonization as aas_jsonization
import aas_core3.verification as aas_verification

import tests.common
import tests.common_jsonization


#: List of identifiers for serialization failures (corresponding to subdirectory names
#: in the directory with test data)
_CAUSES_FOR_DESERIALIZATION_FAILURE = [
    "TypeViolation",
    "RequiredViolation",
    "EnumViolation",
    "NullViolation",
    "UnexpectedAdditionalProperty",
]


class Test_Extension(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Extension`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Extension"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Extension"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Extension`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Extension"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Extension`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_AdministrativeInformation(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.AdministrativeInformation`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "AdministrativeInformation"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "AdministrativeInformation"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.AdministrativeInformation`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "AdministrativeInformation"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.AdministrativeInformation`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_Qualifier(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Qualifier`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Qualifier"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Qualifier"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Qualifier`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Qualifier"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Qualifier`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_AssetAdministrationShell(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.AssetAdministrationShell`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "AssetAdministrationShell"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "AssetAdministrationShell"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.AssetAdministrationShell`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "AssetAdministrationShell"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.AssetAdministrationShell`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_AssetInformation(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.AssetInformation`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "AssetInformation"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "AssetInformation"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.AssetInformation`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "AssetInformation"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.AssetInformation`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_Resource(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Resource`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Resource"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Resource"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Resource`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Resource"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Resource`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_SpecificAssetID(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.SpecificAssetID`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "SpecificAssetId"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "SpecificAssetId"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.SpecificAssetID`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "SpecificAssetId"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.SpecificAssetID`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_Submodel(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Submodel`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Submodel"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Submodel"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Submodel`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Submodel"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Submodel`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_RelationshipElement(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.RelationshipElement`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "RelationshipElement"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "RelationshipElement"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.RelationshipElement`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "RelationshipElement"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.RelationshipElement`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_SubmodelElementList(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.SubmodelElementList`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "SubmodelElementList"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "SubmodelElementList"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.SubmodelElementList`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "SubmodelElementList"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.SubmodelElementList`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_SubmodelElementCollection(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.SubmodelElementCollection`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "SubmodelElementCollection"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "SubmodelElementCollection"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.SubmodelElementCollection`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "SubmodelElementCollection"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.SubmodelElementCollection`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_Property(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Property`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Property"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Property"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Property`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Property"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Property`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_MultiLanguageProperty(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.MultiLanguageProperty`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "MultiLanguageProperty"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "MultiLanguageProperty"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.MultiLanguageProperty`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "MultiLanguageProperty"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.MultiLanguageProperty`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_Range(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Range`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Range"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Range"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Range`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Range"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Range`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_ReferenceElement(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.ReferenceElement`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "ReferenceElement"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "ReferenceElement"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.ReferenceElement`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "ReferenceElement"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.ReferenceElement`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_Blob(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Blob`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Blob"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Blob"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Blob`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Blob"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Blob`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_File(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.File`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "File"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "File"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.File`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "File"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.File`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_AnnotatedRelationshipElement(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.AnnotatedRelationshipElement`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "AnnotatedRelationshipElement"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "AnnotatedRelationshipElement"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.AnnotatedRelationshipElement`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "AnnotatedRelationshipElement"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.AnnotatedRelationshipElement`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_Entity(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Entity`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Entity"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Entity"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Entity`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Entity"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Entity`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_EventPayload(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.EventPayload`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "SelfContained"
                / "Expected"
                / "EventPayload"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            instance = aas_jsonization.event_payload_from_jsonable(jsonable)

            errors = list(aas_verification.verify(instance))

            self.assertListEqual([], errors, f"path is: {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(instance)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.event_payload_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "SelfContained"
                / "Unexpected"
                / cause
                / "EventPayload"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.EventPayload`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.event_payload_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "SelfContained"
                / "Unexpected"
                / cause
                / "EventPayload"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.EventPayload`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    instance = aas_jsonization.event_payload_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(instance))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_BasicEventElement(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.BasicEventElement`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "BasicEventElement"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "BasicEventElement"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.BasicEventElement`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "BasicEventElement"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.BasicEventElement`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_Operation(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Operation`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Operation"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Operation"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Operation`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Operation"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Operation`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_OperationVariable(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.OperationVariable`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "OperationVariable"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "OperationVariable"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.OperationVariable`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "OperationVariable"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.OperationVariable`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_Capability(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Capability`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Capability"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Capability"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Capability`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Capability"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Capability`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_ConceptDescription(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.ConceptDescription`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "ConceptDescription"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "ConceptDescription"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.ConceptDescription`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "ConceptDescription"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.ConceptDescription`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_Reference(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Reference`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Reference"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Reference"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Reference`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Reference"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Reference`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_Key(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Key`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "Key"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Key"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Key`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "Key"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Key`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_LangStringNameType(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.LangStringNameType`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "LangStringNameType"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "LangStringNameType"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.LangStringNameType`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "LangStringNameType"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.LangStringNameType`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_LangStringTextType(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.LangStringTextType`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "LangStringTextType"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "LangStringTextType"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.LangStringTextType`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "LangStringTextType"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.LangStringTextType`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_Environment(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.Environment`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "SelfContained"
                / "Expected"
                / "Environment"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            instance = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(instance))

            self.assertListEqual([], errors, f"path is: {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(instance)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "SelfContained"
                / "Unexpected"
                / cause
                / "Environment"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Environment`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "SelfContained"
                / "Unexpected"
                / cause
                / "Environment"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.Environment`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    instance = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(instance))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_EmbeddedDataSpecification(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.EmbeddedDataSpecification`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "EmbeddedDataSpecification"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "EmbeddedDataSpecification"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.EmbeddedDataSpecification`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "EmbeddedDataSpecification"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.EmbeddedDataSpecification`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_LevelType(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.LevelType`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "LevelType"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "LevelType"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.LevelType`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "LevelType"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.LevelType`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_ValueReferencePair(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.ValueReferencePair`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "ValueReferencePair"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "ValueReferencePair"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.ValueReferencePair`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "ValueReferencePair"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.ValueReferencePair`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_ValueList(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.ValueList`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "ValueList"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "ValueList"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.ValueList`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "ValueList"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.ValueList`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_LangStringPreferredNameTypeIEC61360(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.LangStringPreferredNameTypeIEC61360`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "LangStringPreferredNameTypeIec61360"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "LangStringPreferredNameTypeIec61360"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.LangStringPreferredNameTypeIEC61360`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "LangStringPreferredNameTypeIec61360"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.LangStringPreferredNameTypeIEC61360`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_LangStringShortNameTypeIEC61360(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.LangStringShortNameTypeIEC61360`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "LangStringShortNameTypeIec61360"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "LangStringShortNameTypeIec61360"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.LangStringShortNameTypeIEC61360`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "LangStringShortNameTypeIec61360"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.LangStringShortNameTypeIEC61360`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_LangStringDefinitionTypeIEC61360(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.LangStringDefinitionTypeIEC61360`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "LangStringDefinitionTypeIec61360"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "LangStringDefinitionTypeIec61360"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.LangStringDefinitionTypeIEC61360`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "LangStringDefinitionTypeIec61360"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.LangStringDefinitionTypeIEC61360`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


class Test_DataSpecificationIEC61360(unittest.TestCase):
    """
    Test JSON de/serialization of the concrete class
    :py:class:`aas_core3.types.DataSpecificationIEC61360`.
    """

    def test_ok(self) -> None:
        paths = sorted(
            (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Expected"
                / "DataSpecificationIec61360"
            ).glob("**/*.json")
        )

        for path in paths:
            with path.open("rt") as fid:
                jsonable = json.load(fid)

            container = aas_jsonization.environment_from_jsonable(jsonable)

            errors = list(aas_verification.verify(container))

            self.assertListEqual([], errors, f"path is {path}")

            # Check the round-trip
            another_jsonable = aas_jsonization.to_jsonable(container)
            self.assertListEqual(
                [],
                list(
                    map(
                        str,
                        tests.common_jsonization.check_equal(
                            jsonable, another_jsonable
                        ),
                    )
                ),
            )

    def test_that_deserialization_from_non_object_fails(self) -> None:
        jsonable = "not an object"

        observed_exception: Optional[aas_jsonization.DeserializationException] = None

        try:
            aas_jsonization.environment_from_jsonable(jsonable)
        except aas_jsonization.DeserializationException as exception:
            observed_exception = exception

        assert observed_exception is not None
        self.assertEqual(
            "Expected a mapping, but got: <class 'str'>", observed_exception.cause
        )

        self.assertEqual("", str(observed_exception.path))

    def test_deserialization_failures(self) -> None:
        for cause in _CAUSES_FOR_DESERIALIZATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "DataSpecificationIec61360"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.DataSpecificationIEC61360`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                observed_exception: Optional[
                    aas_jsonization.DeserializationException
                ] = None

                try:
                    _ = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    observed_exception = exception

                assert (
                    observed_exception is not None
                ), f"Expected an exception, but got none for: {path}"

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".exception"),
                    got=f"{observed_exception.path}: {observed_exception.cause}",
                )

    def test_verification_failures(self) -> None:
        for cause in tests.common.CAUSES_FOR_VERIFICATION_FAILURE:
            base_dir = (
                tests.common.TEST_DATA_DIR
                / "Json"
                / "ContainedInEnvironment"
                / "Unexpected"
                / cause
                / "DataSpecificationIec61360"
            )

            if not base_dir.exists():
                # There are no failure cases
                # for :py:class:`aas_core3.types.DataSpecificationIEC61360`
                # and this ``cause``.
                continue

            for path in sorted(base_dir.glob("**/*.json")):
                with path.open("rt") as fid:
                    jsonable = json.load(fid)

                try:
                    container = aas_jsonization.environment_from_jsonable(jsonable)
                except aas_jsonization.DeserializationException as exception:
                    raise AssertionError(
                        f"Expected no deserialization exception from {path}"
                    ) from exception

                errors = list(aas_verification.verify(container))

                self.assertGreater(
                    len(errors),
                    0,
                    f"Expected verification errors from {path}, but got none",
                )

                tests.common.record_or_check(
                    path=path.parent / (path.name + ".errors"),
                    got="\n".join(f"{error.path}: {error.cause}" for error in errors),
                )


if __name__ == "__main__":
    unittest.main()


# This code has been automatically generated by:
# dev_scripts/test_codegen/generate_test_for_jsonization_of_concrete_classes.py
# Do NOT edit or append.
